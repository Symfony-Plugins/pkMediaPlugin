<?php

/**
 * This class has been auto-generated by the Doctrine ORM Framework
 */
abstract class PluginpkMediaItem extends BasepkMediaItem
{
  public function save(Doctrine_Connection $conn = null)
  {
    if (!$this->getOwnerId())
    {
      $user = sfContext::getInstance()->getUser();
      if ($user->getGuardUser())
      {
        $this->setOwnerId($user->getGuardUser()->getId());
      }
    }
    // Let the culture be the user's culture
    return pkZendSearch::saveInDoctrineAndLucene($this, null, $conn);
  }

  public function doctrineSave($conn)
  {
    return parent::save($conn);
  }

  public function delete(Doctrine_Connection $conn = null)
  {
    $ret = pkZendSearch::deleteFromDoctrineAndLucene($this, null, $conn);
    $this->clearImageCache();
    // Don't even think about trashing the original until we know
    // it's gone from the db and so forth
    unlink($this->getOriginalPath());
    return $ret;
  }

  public function doctrineDelete($conn)
  {
    return parent::delete($conn);
  }
  
  public function updateLuceneIndex()
  {
    pkZendSearch::updateLuceneIndex($this, array(
      'type' => $this->getType(),
      'title' => $this->getTitle(),
      'description' => $this->getDescription(),
      'credit' => $this->getCredit(),
      'tags' => implode(", ", $this->getTags())
    ));
  }
  
  public function getOriginalPath($format = false)
  {
    if ($format === false)
    {
      $format = $this->getFormat();
    }
    return pkMediaItemTable::getDirectory() . 
      DIRECTORY_SEPARATOR . $this->getSlug() . ".original.$format";
  }
  public function clearImageCache($deleteOriginals = false)
  {
    if (!$this->getId())
    {
      return;
    }
    $cached = glob(pkMediaItemTable::getDirectory() . DIRECTORY_SEPARATOR . $this->getSlug() . ".*");
    foreach ($cached as $file)
    {
      if (!$deleteOriginals)
      {
        if (strpos($file, ".original.") !== false)
        {
          continue;
        }
      }
      unlink($file); 
    }
  }
  public function preSaveImage($file)
  {
    $in = fopen($file, "rb");
    $data = fread($in, 4);
    fclose($in);
    if ($data === '%PDF')
    {
      $this->format = 'pdf';
      $this->clearImageCache(true);
      // PATH-constructing cleverness borrowed from pkImageConverter,
      // which it really ought to be refactored back into as part of
      // a dimensions function that supports PDF (TODO)
      $path = sfConfig::get("app_pkimageconverter_path", "");
      if (strlen($path)) {
        if (!preg_match("/\/$/", $path)) {
          $path .= "/";
        }
      }
      # Bounding box goes to stderr, not stdout! Charming
      $cmd = "(PATH=$path:\$PATH; export PATH; gs -sDEVICE=bbox -dNOPAUSE -dFirstPage=1 -dLastPage=1 -r100 -q " . escapeshellarg($file) . " -c quit) 2>&1";
      $in = popen($cmd, "r");
      $data = stream_get_contents($in);
      // Actual nonfatal errors in the bbox output mean it's not safe to just
      // read this naively with fscanf, look for the good part
      if (preg_match("/%%BoundingBox: \d+ \d+ (\d+) (\d+)/", $data, $matches))
      {
        $this->width = $matches[1];
        $this->height = $matches[2];
      }
      else
      {
        // Got no dimensions. TODO: I return false here but the calling
        // code doesn't really cope yet. It's problematic: what if this is
        // a replacement for another file? Meanwhile, supply bogus dimensions
        // to prevent comical scaling errors if it's somehow a valid PDF
        $this->width = 850;
        $this->height = 1100;
        return false;
      }
      pclose($in);
      
      // TODO: if I don't get $x2 and $y2, ghostscript is uninstalled or misconfigured,
      // and I should fake it by always rendering a big PDF icon... it could also
      // be a bad PDF
            
    }
    else
    {
      $formats = array(
        IMAGETYPE_JPEG => "jpg",
        IMAGETYPE_PNG => "png",
        IMAGETYPE_GIF => "gif"
      );
      $data = getimagesize($file);
      if (count($data) < 3)
      {
        return false;
      }
      if (!isset($formats[$data[2]]))
      {
        return false;
      }
      $format = $formats[$data[2]];
      $this->clearImageCache(true);
      $this->width = $data[0];
      $this->height = $data[1];
      $this->format = $format;
    }
    return true;
  }

  public function saveImage($file)
  {
    if (!$this->width)
    {
      $this->preSaveImage($file);
    }
    $result = copy($file, $this->getOriginalPath($this->getFormat()));
    return $result;
  }

  public function getEmbedCode($width, $height, $resizeType, $format = 'jpg', $absolute = false)
  {
    if ($height === false)
    {
      // Scale the height. I had this backwards
      $height = floor(($width * $this->height / $this->width) + 0.5); 
    }
    // Accessible alt title
    $title = htmlspecialchars($this->getTitle());
    // It would be nice if partials could be used for this.
    // Think about whether that's possible.
    if ($this->getType() === 'video')
    {
      if ($this->embed)
      {
        // Solution for non-YouTube videos based on a manually
        // provided thumbnail and embed code
        return str_replace(array('_TITLE_', '_WIDTH_', '_HEIGHT_'),
          array($title, $width, $height), $this->embed);
      }
      // TODO: less YouTube-specific
      $serviceUrl = $this->getServiceUrl();
      $embeddedUrl = $this->youtubeUrlToEmbeddedUrl($serviceUrl);
      return <<<EOM
<object alt="$title" width="$width" height="$height"><param name="movie" value="$embeddedUrl"></param><param name="allowFullScreen" value="true"></param><param name="allowscriptaccess" value="always"></param><embed alt="$title" src="$embeddedUrl" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" width="$width" height="$height"></embed></object>
EOM
      ;
    }
    elseif (($this->getType() == 'image') || ($this->getType() == 'pdf'))
    {
      $controller = sfContext::getInstance()->getController();
      $slug = $this->getSlug();
      // Use named routing rule to ensure the desired result (and for speed)
      return "<img alt=\"$title\" src='" . $controller->genUrl("@pk_media_image?" . 
        http_build_query(
          array("slug" => $slug, 
            "width" => $width, 
            "height" => $height, 
            "resizeType" => $resizeType,
            "format" => $format)), $absolute) .
            "' />";
    }
    else
    {
      throw new Exception("Unknown media type in getEmbedCode: " . $this->getType());
    }
  }
  protected function youtubeUrlToEmbeddedUrl($url)
  {
    $url = str_replace("/watch?v=", "/v/", $url);
    $url .= "&fs=1";
    return $url;
  }
  public function userHasPrivilege($privilege, $user = false)
  {
    if ($user === false)
    {
      $user = sfContext::getInstance()->getUser();
    }
    if ($privilege === 'view')
    {
      if ($this->getViewIsSecure())
      {
        if (!$user->isAuthenticated())
        {
          return false;
        }
      }
      return true;
    }
    if ($user->hasCredential('media_admin'))
    {
      return true;
    }
    $guardUser = $user->getGuardUser();
    if (!$guardUser)
    {
      return false;
    }
    if ($this->getOwnerId() === $guardUser->getId())
    {
      return true;
    }
    return false;
  }
  
  // Returns a Symfony action URL. Call url_for or use sfController for final routing.
  
  public function getScaledUrl($options)
  {
    $options = pkDimensions::constrain($this->getWidth(), $this->getHeight(), $this->getFormat(), $options);

    return "pkMedia/image?" . http_build_query(
      array("slug" => $this->slug, "width" => $options['width'], "height" => $options['height'], 
        "resizeType" => $options['resizeType'], "format" => $options['format']));
  }
}
